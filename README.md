# 设计模式学习笔记

## 面向对象设计原则
### 单一职责原则
**单一职责原则**：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。  

一个类承担的职责越多，它被复用的可能性越小，一个类承担的职责越多，职责之间的耦合越紧密。
### 开闭原则
**开闭原则**：软件实体应当对软件扩展开放，对修改关闭。  

使软件具有较好的稳定性和延续性，抽象化是开闭原则的关键。
### 里氏替换原则
**里氏替换原则**：所有引用基类的地方必须能够透明地使用其子类的对象。  

父类引用指向子类对象。是实现开闭原则的重要方式之一。
### 依赖倒转原则
**依赖倒转原则**：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖细节，细节应该依赖抽象。  

依赖倒转原则要求针对接口编程，不要针对实现编程。    

>多数情况下，开闭元则、里氏替换原则和依赖倒转原则会同时出现，开闭原则是目标，里氏替换原则是基础，依赖倒转原则是手段。
### 接口隔离原则
**接口隔离原则**：客户端不应该依赖那些它不需要的接口。
### 合成复用原则
**合成复用原则**：优先使用对象组合，而不是通过继承来达到复用的目的。  

### 迪米特法则
**迪米特法则**：每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。  

迪米特法则要求在设计系统时应该尽量减少对象之间的交互，如果两个对象之间不必彼此通信，那么这两个对象就不应当发生任何直接的互相作用。使用迪米特法则的目的是使类与类之间保持松散的耦合关系。

## 简单工厂模式
**定义**：定义一个工厂类，它可以根据参数的不同返回不同类型的实例，被创建的实例通常具有共同的父类。  
**优点**：  
+ 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例，客户端可以免除直接创建产品对象的职责，而仅仅消费产品，简单工厂模式实现了对象创建和使用的分离。  

+ 客户端无须知道所创建的具体产品类的类名，只需知道具体产品类所对应的参数即可，减少记忆量。  

+ 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。  
**缺点**：
+ 工厂类职责过重，一旦不能正常工作，整个系统都将受到影响。  

+ 使用简单工厂模式势必会增加系统中类的个数，增加了系统的复杂度和理解难度。  

+ 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。  

+ 简单工厂模式使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

## 工厂模式
**定义**：定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化，工厂方法模式让一个类的实例化延迟到其子类。
**优点**：
+ 工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类被实例化这一细节，用户只需关心所需产品对应的工厂，无需关心创建细节，甚至无须知道具体产品类的类名。  

+ 在系统中加入新产品时无需修改抽象工厂和抽象产品提供的接口，无须修改客户端和其他具体工厂和具体产品，只要添加一个具体工厂和具体产品即可，系统的扩展性变得非常好，完全符合开闭原则。  

**缺点**：
+ 在添加新产品时需要编写具体产品类和对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，会给系统带来额外的开销。  

+ 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。  

## 抽象工厂模式
**定义**：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。  
**优点**：
+ 抽象工厂模式隔离了具体类的生成，使得客户端并不需要知道什么被创建。由于这种隔离，更换一个具体工厂类就相对容易，所有具体工厂类都实现了抽象工厂中定义的公共接口，因此只需要改变具体工厂的实例就可以在某种程度上改变了整个软件系统的行为。  

+ 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。  

+ 增加新的产品族很方便，无须修改现有系统，符合开闭原则。  

**缺点**：
+ 增加新的产品结构很麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，带来不便，违背了开闭原则。
